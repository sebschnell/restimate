{
    "collab_server" : "",
    "contents" : "rm(list = ls());\nsetwd(\"C:/Users/ses/Documents/LiDAR_Satellite\");\n\nlibrary(\"data.table\");\nlibrary(\"sqldf\");\nlibrary(\"ggplot2\");\nlibrary(\"doParallel\");\nlibrary(\"foreach\");\nlibrary(\"restimate\");\nlibrary(\"stringr\");\n\n# Simulation parameters ---------------------------------------------------\n\ndb <- dbConnect(SQLite(), dbname = \"data/population/pop.sqlite\");\ndt_pop <- data.table(dbGetQuery(conn = db, \"SELECT row, col, agb, sat_h_mean, sat_h_p95, sat_p_all_gt_150, id_mun FROM Population\"));\ndbDisconnect(db);\n\ndt_pop <- readRDS(\"E:/data/LiDAR_Satellite/population/pop.RDS\");\ndt_pop[, h_mean := NULL];\ndt_pop[, h_p50 := NULL];\ndt_pop[, h_p10 := NULL];\ndt_pop[, p_all_gt_150 := NULL];\ndt_pop[, mean_5x5 := NULL];\ndt_pop[, bright := NULL];\ndt_pop[, B8 := NULL];\ndt_pop[, B6 := NULL];\ndt_pop[, B4 := NULL];\ndt_pop[, B3 := NULL];\n\nsetkey(dt_pop, col);\n\n# Population parameters\nN <- nrow(dt_pop);\nNI <- length(unique(dt_pop[, col]));\n\nt <- dt_pop[, sum(agb)];\n\n# Add dummy variables\ndt_pop[, ':='(d1 = 1L,\n              d2 = ifelse(id_mun == 2, 1L, 0L),\n              d3 = ifelse(id_mun == 3, 1L, 0L),\n              d4 = ifelse(id_mun == 4, 1L, 0L))];\ndt_pop[, id_mun := as.factor(id_mun)];\n\ndt_strat <- dt_pop[, list(t = sum(agb),\n                          d1 = mean(d1),\n                          d2 = mean(d2),\n                          d3 = mean(d3),\n                          d4 = mean(d4),\n                          h_mean = mean(sat_h_mean),\n                          h_mean_p_all = mean(sat_h_mean*sat_p_all_gt_150),\n                          N_a = .N),\n                   keyby = list(col, id_mun)];\ndt_strat <- rbind(dt_pop[, list(id_mun = 0,\n                                t = sum(agb),\n                                d1 = mean(d1),\n                                d2 = mean(d2),\n                                d3 = mean(d3),\n                                d4 = mean(d4),\n                                h_mean = mean(sat_h_mean),\n                                h_mean_p_all = mean(sat_h_mean*sat_p_all_gt_150),\n                                N_a = .N),\n                         keyby = list(col)],\n                  dt_strat);\nsetkey(dt_strat, col, id_mun);\n#Ensure that all each PSU has every stratum ID even if combination does not exist\ndt_strat <- dt_strat[CJ(unique(col), unique(id_mun))];\nfor (c in seq_along(dt_strat)) {\n  set(dt_strat, i = which(is.na(dt_strat[[c]])), j = c, 0) #Replace with zero\n}\n\n# Check for trend in PSU totals and means\ndt_psu <- dt_pop[,\n                 list(N_i = .N,\n                      agb_tot = sum(agb),\n                      agb_mean = mean(agb)),\n                 keyby = col];\n\nsummary(lm(agb_tot ~ col, dt_psu));\nggplot(dt_psu, aes(y = agb_mean, x = col)) +\n  geom_point() +\n  stat_smooth(method = \"lm\", se = FALSE);\nggplot(dt_psu, aes(y = N_i, x = col)) +\n  geom_point() +\n  stat_smooth(se = FALSE);\n\n# Systematic sample of PSU's\ndist_psu <- 3200; # Distance between laser profiles\npsu_width <- 12.5;\na <- dist_psu/psu_width;\nn <- 400L; # Number of SSU's allocated over selected PSU's\n#n_min <- 1; # Minimum number of sample units in a PSU\nh <- 5L; # Number of strata\nnI <- 40;\n\nMI <- 100L; # Number of first stage repetitions\nMII <- 10L; # Number of second stage repetitions\n\ndt_samp_dstrb <- data.table(id = rep(seq.int(MI*MII), each = 5L),\n                            id_mun = rep(0L:4L, MI*MII),\n                            t_srs = rep(0.0, MI*MII*h),\n                            v_srs = rep(0.0, MI*MII*h),\n                            t_ma = rep(0.0, MI*MII*h),\n                            v_ma = rep(0.0, MI*MII*h),\n                            v_pb_ma = rep(0.0, MI*MII*h),\n                            v_ma_alt = rep(0.0, MI*MII*h),\n                            t_mb = rep(0.0, MI*MII*h),\n                            v_mb = rep(0.0, MI*MII*h));\n\ndt_model_param <- data.table(id = seq.int(MI*MII),\n                             d1 = rep(0.0, MI*MII),\n                             d2 = rep(0.0, MI*MII),\n                             d3 = rep(0.0, MI*MII),\n                             d4 = rep(0.0, MI*MII),\n                             h_mean = rep(0.0, MI*MII),\n                             h_mean_p_all = rep(0.0, MI*MII));\n\ndt_model_pred <- data.table(id = rep(seq.int(MI*MII), n),\n                            obs = rep(0.0, MI*MII*n),\n                            pred = rep(0.0, MI*MII*n));\n\ncount <- 0L;\npb <- txtProgressBar(min = 0, max = MI*MII, style = 3)\nfor (mI in seq.int(MI)) {\n  dt_psu_s <- dt_psu[sample(NI, nI), list(col, N_i)]; # First stage sample\n  setkey(dt_psu_s, col);\n\n  # Self-weighting design, proportional to PSU size\n  dt_psu_s[, n_i := round_fix_sum(n*N_i/sum(N_i))];\n\n  for (mII in seq.int(MII)) {\n    # Second stage sample\n    dt_ssu_s <- dt_pop[dt_psu_s][, .SD[sample(.N, n_i)], by = col][, list(col, agb, sat_h_mean, sat_h_p95, sat_p_all_gt_150, id_mun)];\n\n    agb_model <- lm(agb ~ id_mun + sat_h_mean + sat_h_mean:sat_p_all_gt_150,\n                    data = dt_ssu_s,\n                    x = TRUE);\n    b <- coef(agb_model);\n    names(b) <- c(\"d1\", str_replace(names(b[2:length(b)]), \"id_mun\", \"d\"));\n    names(b) <- str_replace(names(b), \"sat_h_mean:sat_p_all_gt_150\", \"h_mean_p_all\");\n    names(b) <- str_replace(names(b), \"sat_h_mean\", \"h_mean\");\n\n    dt_ssu_s[, ':='(pred = fitted.values(agb_model),\n                    res = residuals(agb_model))];\n\n    # Predicted PSU totals by strata\n    dt_psu_tot <- dt_strat[dt_psu_s];\n    dt_psu_tot[, w_i := N_a/sum(N_a), by = id_mun];\n    dt_psu_tot[, t_pred := as.matrix(dt_psu_tot[, names(b), with = FALSE])%*%b*N_a];\n\n    dt_aux <- dt_psu_tot[,\n                         list(d1 = sum(d1*w_i),\n                              d2 = sum(d2*w_i),\n                              d3 = sum(d3*w_i),\n                              d4 = sum(d4*w_i),\n                              h_mean = sum(h_mean*w_i),\n                              h_mean_p_all = sum(h_mean_p_all*w_i)),\n                         keyby = id_mun];\n    dt_aux <- cbind(dt_aux[, list(id_mun)], dt_aux[, names(b), with = FALSE]);\n    setkey(dt_aux, id_mun);\n\n    # Estimate population total (collapse strata)\n    setkey(dt_ssu_s, col);\n    setkey(dt_psu_tot, col);\n    dt_s <- dt_ssu_s[dt_psu_tot[id_mun == 0, list(col, N_i, n_i, t_pred)]];\n\n    est_ht <- c(id_mun = 0,\n                est_ts_srswor(dt_s, NI = NI, nI = nI, N_i = quote(N_a),\n                              id_psu = 'col', y = quote(agb)));\n\n    est_ma <- c(id_mun = 0,\n                est_ts_ma_srswor(dt_s, res = quote(res), t_pred = quote(t_pred),\n                                 NI = NI, nI = nI, N_i = quote(N_a),\n                                 id_psu = 'col', y = quote(agb)));\n\n    # Estimate strata totals\n    setkey(dt_ssu_s, col, id_mun);\n    setkey(dt_psu_tot, col, id_mun);\n    dt_s_strat <- dt_ssu_s[dt_psu_tot[id_mun != 0, list(col, id_mun, N_i, n_i, t_pred)]];\n\n    dt_est_ht <- rbind(est_ht,\n                       dt_s_strat[, est_ts_srswor(.SD, NI = NI, nI = nI,\n                                                  N_i = quote(N_a),\n                                                  id_psu = 'col',\n                                                  y = quote(agb)),\n                                  keyby = id_mun]);\n\n    dt_est_ma <- rbind(est_ma,\n                       dt_s_strat[, est_ts_ma_srswor(.SD, res = quote(res),\n                                                     t_pred = quote(t_pred),\n                                                     NI = NI, nI = nI,\n                                                     N_i = quote(N_a),\n                                                     id_psu = 'col',\n                                                     y = quote(agb)),\n                                  keyby = id_mun]);\n\n    vcov_parm <- vcov(agb_model);\n    dt_est_mb <- data.table(id_mun = 0:(h-1), t_hat = rep(0.0, h), v_hat = rep(0.0, h));\n    for (i in dt_est_mb[, id_mun]) {\n      est_mb <- est_ts_mb(dt_samp = dt_psu_tot[id_mun == i, list(t_pred)],\n                          X = as.matrix(dt_aux[id_mun == i, names(b), with = FALSE]),\n                          parm_cov = vcov_parm,\n                          N = dt_strat[id_mun == i, sum(N_a)], NI = NI, nI = nI);\n      set(dt_est_mb, i + 1L, 2L:3L, est_mb);\n    }\n\n    dt_psu_tot[, mean_pred := sum(t_pred)/sum(N_a), by = id_mun];\n    dt_psu_tot[, t_res := t_pred - mean_pred*N_a];\n    X <- as.matrix(dt_aux[id_mun == 0, names(b), with = FALSE])\n    NI^2*(1/nI - 1/NI)*dt_psu_tot[id_mun == 0, sum(t_res^2)/(nI - 1)] + N^2*X%*%vcov_parm%*%t(X)\n\n\n    w_a <- dt_pop[, .N, keyby = id_mun][, N]/N;\n    N_a <- dt_psu_tot[id_mun != 0, mean(N_a), keyby = id_mun][, V1];\n    w_matrix <- outer(w_a/N_a, w_a/N_a);\n    cs_cov <- matrix(0, h - 1, h - 1);\n    mod_cov <- cs_cov;\n    for (i in dt_est_mb[, id_mun]) {\n      for (j in dt_est_mb[, id_mun]) {\n        cs_cov[i, j] <- sum(dt_psu_tot[id_mun == i, t_res]*dt_psu_tot[id_mun == j, t_res]);\n        mod_cov[i, j] <- as.matrix(dt_aux[id_mun == i, names(b), with = FALSE])%*%vcov_parm%*%t(as.matrix(dt_aux[id_mun == j, names(b), with = FALSE]))\n      }\n    }\n    v_pb <- 1/nrow(dt_psu_s)*sum(w_matrix*(cs_cov/(nrow(dt_psu_s) - 1)));\n    v_mb <- sum(w_matrix*mod_cov);\n    v <- v_pb + v_mb\n    sqrt(v)\n    dt_psu_tot[id_mun == 0, 1/40*var(t_pred)]\n\n\n    # Store results\n    r_start <- count*h + 1L;\n    r_end <- r_start + h - 1L;\n    set(dt_samp_dstrb,\n        r_start:r_end,\n        3L:10L,\n        cbind(dt_est_ht[, list(t_hat, v_hat)],\n              dt_est_ma[, list(t_hat, v_ht, v_pb_ma, v_alt)],\n              dt_est_mb[, list(t_hat, v_hat)]));\n    r_start <- count*n + 1L;\n    r_end <- r_start + n - 1L;\n    set(dt_model_pred,\n        r_start:r_end,\n        2L:3L,\n        list(obs = dt_ssu_s[, agb],\n             pred = dt_ssu_s[, pred]));\n    count <- count + 1L;\n    # Handle case when domains are missing in the sample\n    idx <- which((names(dt_model_param)[-1] %in% names(b)) == FALSE);\n    if (length(idx) != 0) {\n      b <- c(b[1:(idx - 1)], NA, b[(idx + 1):length(b)]);\n    }\n    set(dt_model_param,\n        count,\n        2L:7L,\n        as.list(b));\n    setTxtProgressBar(pb, count);\n  }\n}\nclose(pb);\n\n# Save the sample distribution\n# outFile <- \"R/Simulation/Distributions/TwoStage_SRSwoR_HT.txt\";\n# if (file.exists(outFile) == FALSE) {\n#    write.table(DtSampDistrb, file = outFile, row.names = FALSE);\n# } else {\n#    warning(\"File exists!\");\n# }\n\n# DtSampDistrb <- data.table(read.table(outFile, header = TRUE));\n\n## Accuracy of Monte Carlo simulation\n# Check normality of the distribution of t_hat\n# Skewness of the sample distribution\nlibrary(e1071);\ndt_samp_dstrb[, skewness(t_hat), by = id_mun];\n\n# Density of normal distribution compared to observed values\ndt_samp_dstrb[,\n              t_norm := dnorm(t_hat,\n                              mean = mean(t_hat),\n                              sd = sd(t_hat)),\n              by = id_mun];\n\nggplot(dt_samp_dstrb, aes(t_hat)) +\n  geom_histogram(aes(y = ..density..), fill = \"grey\", colour = \"black\") +\n  geom_line(aes(y = t_norm)) +\n  facet_wrap( ~ id_mun, scales = 'free');\n\n# qq-plots\ndt_qq_line <- dt_samp_dstrb[, list(y25 = quantile(t_hat, 0.25),\n                                   y75 = quantile(t_hat, 0.75),\n                                   x25 = qnorm(0.25),\n                                   x75 = qnorm(0.75)),\n                            by = id_mun];\ndt_qq_line[, slope := (y75 - y25)/(x75 - x25), by = id_mun];\ndt_qq_line[, int := y25 - slope*x25, by = id_mun];\n\nggplot(dt_samp_dstrb, aes(sample = t_hat)) +\n  stat_qq() +\n  geom_abline(data = dt_qq_line, aes(intercept = int, slope = slope)) +\n  facet_wrap( ~ id_mun, scales = 'free');\n\n# Correlation between t_hat and v_hat\ndt_samp_dstrb[, cor(t_hat, v_hat), by = id_mun];\n\nalpha <- 0.975;\nz <- qnorm(p = alpha);\ndt_samp_dstrb[, ci := z * sqrt(v_hat)];\ndt_samp_dstrb[, ':='(t_hat_low = t_hat - ci,\n                     t_hat_up = t_hat + ci)];\n\nsetkey(dt_samp_dstrb, id_mun);\ndt_samp_dstrb <- dt_samp_dstrb[dt_strat];\ndt_sim_res <- dt_samp_dstrb[,\n                            list(t_emp = mean(t_hat),\n                                 v_emp = var(t_hat, na.rm = TRUE),\n                                 v_ana = mean(v_hat, na.rm = TRUE),\n                                 n_cover = sum((t >= t_hat_low & t <= t_hat_up), na.rm = TRUE),\n                                 n_low = sum(t_hat_up < t, na.rm = TRUE),\n                                 n_up = sum(t_hat_low > t, na.rm = TRUE),\n                                 p2.5 = sqrt(quantile(v_hat, 0.25, na.rm = TRUE)),\n                                 p97.5 = sqrt(quantile(v_hat, 0.975, na.rm = TRUE))),\n                            keyby = id_mun];\ndt_sim_res <- dt_sim_res[dt_strat];\ndt_sim_res[, bias := t_emp - t];\ndt_sim_res[, RMSE := sqrt(bias^2 + sqrt(v_emp)^2)];\ndt_sim_res[, ':='(cv_emp = sqrt(v_emp)/t * 100,\n                  cv_ana = sqrt(v_ana)/t * 100,\n                  bias_rel = bias/t * 100,\n                  RRMSE = RMSE/t * 100,\n                  v_bias = (v_ana - v_emp)/v_emp * 100,\n                  cr = n_cover/(MI*MII),\n                  fr_below = n_low/(MI*MII),\n                  fr_up = n_up/(MI*MII))];\n\n\ndt_samp_dstrb[, v_cum := cumsum(v_ma)/id, by = id_mun];\nggplot(dt_samp_dstrb, aes(x = id, y = v_cum)) +\n  geom_line() +\n  geom_hline(aes(yintercept = t), dt_strat) +\n  facet_wrap(~ id_mun, scales = 'free');\n\n\n# Export to clipboard (Excel)\nwrite.table(DtSimRes,\n            \"clipboard\",\n            sep = \"\\t\",\n            col.names = FALSE,\n            row.names = FALSE);\n\ndt_samp_dstrb[id_mun == 0,\n              list((mean(t_mb) - t)/t*100,\n                   sqrt(var(t_mb))/mean(t_mb)*100,\n                   sqrt(mean(v_mb))/mean(t_mb)*100)];\n\n",
    "created" : 1474445296631.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "730147706",
    "id" : "B2DE20E1",
    "lastKnownWriteTime" : 1474394415,
    "last_content_update" : 1474394415,
    "path" : "~/LiDAR_Satellite/R/simulation/two_stage_srs.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}